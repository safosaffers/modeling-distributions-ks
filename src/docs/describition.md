## Инструкция по реализации критерия Пирсона

### 1. Ввод данных
- Пользователь выбирает тип распределения в `comboBox`:
  - `"Равномерное распределение"` → использовать данные из `sample_uniform`
  - `"Нормальное распределение"` → использовать данные из `sample_normal`
  - `"Показательное распределение"` → использовать данные из `sample_exponential`
- При выборе элемента в `comboBox`:
  - Загрузить соответствующую выборку в `teSample` (в виде строки чисел, разделённых пробелами или переводами строк).

### 2. Обработка нажатия кнопки `btnPirson`
При нажатии:
1. **Прочитать выборку** из `teSample` → преобразовать в числовой массив `data`.
2. **Определить гипотетическое распределение** на основе текущего значения `comboBox`.
3. **Оценить параметры** распределения по `data`:
   - Для **нормального**:  
     mu = среднее(data)  
     sigma = стандартное_отклонение(data, ddof=1)
   - Для **равномерного**:  
     a = min(data)  
     b = max(data)
   - Для **показательного**:  
     lambda = 1 / среднее(data)
4. **Построить интервалы** для критерия Пирсона:
   - Рекомендуется использовать **k ≈ sqrt(n)** интервалов (n = len(data)), но не менее 5 и не более 20.
   - Для корректности: объединить интервалы, где ожидаемая частота < 5.
5. **Вычислить статистику хи-квадрат**:
chi2 = сумма по i от 1 до k: (O_i - E_i)^2 / E_i

где:
- `O_i` — наблюдаемая частота в i-м интервале,
- `E_i = n * (F(x_{i}) - F(x_{i-1}))` — ожидаемая частота,
- `F` — теоретическая функция распределения (см. ниже).

6. **Определить число степеней свободы**:
df = k - 1 - r

где `r` — число оценённых параметров:
- нормальное: r = 2 (mu, sigma)
- равномерное: r = 2 (a, b)
- показательное: r = 1 (lambda)

7. **Вычислить p-value**:
- Использовать функцию распределения хи-квадрат:  
  `p = 1 - CDF_chi2(chi2, df)`

8. **Сформировать вывод**:
- Если `p < 0.05` → «Гипотеза о соответствии распределению отвергается»
- Иначе → «Гипотеза о соответствии распределению не противоречит данным»

9. **Записать результат в lblPirsonInfo**:
Пример текста:
χ² = {chi2:.3f}, df = {df}, p = {p:.4f}
Вывод: {вывод}


### 3. Построение графика в `vlHistogram`
На графике отобразить:
1. **Гистограмму** выборки (`data`) с `density=True`.
2. **Теоретическую плотность** распределения:
- Нормальное:  
  `f(x) = (1 / (sigma * sqrt(2*pi))) * exp(-0.5 * ((x - mu)/sigma)^2)`
- Равномерное:  
  `f(x) = 1 / (b - a)` при `a ≤ x ≤ b`, иначе 0
- Показательное:  
  `f(x) = lambda * exp(-lambda * x)` при `x ≥ 0`, иначе 0
3. **(Рекомендуется)** — вертикальные линии, разделяющие интервалы Пирсона.
4. **(Рекомендуется)** — ступенчатую кривую ожидаемых плотностей по интервалам (для наглядности расчёта χ²).

### 4. Формулы плотности и функции распределения (для расчёта E_i)

- **Нормальное распределение**:
  - Плотность: `f(x) = (1 / (sigma * sqrt(2*pi))) * exp(-0.5 * ((x - mu)/sigma)^2)`
  - ФР: `F(x) = 0.5 * (1 + erf((x - mu) / (sigma * sqrt(2))))`

- **Равномерное распределение**:
  - Плотность: `f(x) = 1 / (b - a)` для `x ∈ [a, b]`
  - ФР: `F(x) = 0` если `x < a`, `(x - a)/(b - a)` если `a ≤ x ≤ b`, `1` если `x > b`

- **Показательное распределение**:
  - Плотность: `f(x) = lambda * exp(-lambda * x)` для `x ≥ 0`
  - ФР: `F(x) = 1 - exp(-lambda * x)` для `x ≥ 0`

> Примечание: для вычисления `F(x)` рекомендуется использовать готовые функции из `scipy.stats` (например, `norm.cdf`, `uniform.cdf`, `expon.cdf`).

### 5. Важные замечания
- Все расчёты должны использовать одну и ту же выборку, полученную из `teSample`.
- При изменении `comboBox` — обновлять `teSample`, но **не запускать расчёт автоматически** (только по кнопке).
- График должен очищаться/перерисовываться полностью при каждом нажатии `btnPirson`.